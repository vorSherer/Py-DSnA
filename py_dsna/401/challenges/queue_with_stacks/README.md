# Queue with Stacks
Implementation of a pseudo-queue class that uses two stack objects internally.

## Challenge
#### Features
Create a brand new __`PseudoQueue`__ class. *Do not use an existing Queue.* Instead, this PseudoQueue class will implement our standard queue interface (the two methods listed below), but will internally only utilize 2 Stack objects. Ensure that you create your class with the following methods:

__`enqueue(value)`__ which inserts value into the PseudoQueue, using a first-in, first-out approach.
__`dequeue()`__ which extracts a value from the PseudoQueue, using a first-in, first-out approach.
The __`Stack`__ instances have only __push__, __pop__, and __peek__ methods. You should use your own Stack implementation. Instantiate these Stack objects in your PseudoQueue constructor.

## Approach & Efficiency
<!-- Both Stack and Queue were implemented using a singly linked list methodology. <br>
__Big O space__ for each will be __O(n)__ and <br>
__Big O time__ for each operation is __O(1)__. -->

## API
<!-- This implementation has access to the Node class and all the properties on the Linked List class. -->

## Solution
My code is [here.](./queue_with_stacks.py)

## Code Challenge 10 whiteboards:
#### Queue with Stacks - 
<!-- ![CC-11 Queue-with-Stacks -1](./assets/queue-w-stack_WB-1.png)

![CC-10 Queue -4](./assets/queue_WB-4.png) -->


## Task Checklist: <br>
- [ ] Top-level README “Table of Contents” is updated <br>
- [ ] Feature tasks for this challenge are completed <br>
- [ ] Unit tests written and passing <br>
    - [ ] “Happy Path” - Expected outcome <br>
    - [ ] Expected failure <br>
    - [ ] Edge Case (if applicable/obvious) <br>
- [ ] README for this challenge is complete <br>
    - [ ] Summary, Description, Approach & Efficiency, Solution <br>
    - [ ] Link to code <br>
    - [ ] Pictures of whiteboards <br>
